#start server
docker run -it --rm -p 8200:8200 docker.io/library/vault:1.13.3

#start client
docker run -it --rm --net host docker.io/library/vault:1.13.3 sh

# set address
export VAULT_ADDR='http://0.0.0.0:8200'
#export VAULT_ADDR="https://dev-vault.example.com

# check server status
vault status

# auth
vault login -method=token
#vault login -method=ldap username=zorg

# list enabled instances of engines
vault secrets list

# check authorization
vault policy list

---------------------------------------------------------------------------------------------------------------------------
# FYI https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2
# create dedicated instance of kv engine
vault secrets enable -version=2 -path=terra-kv-zorg -description="pilot, to be deleted" kv && vault secrets list

# update policy
vault policy read policy-devops > p.json

vim p.json
path "terra-kv-zorg/*" {
  capabilities = ["create", "read", "update", "patch", "delete", "list", "sudo"]
}
 
vault policy write policy-devops p.json

# create secret
vault kv put -mount=terra-kv-zorg terra-vsphere-main-api domain="rig.example.com" login="joe" password="blahblah"

# get record list
vault kv list terra-kv-zorg

# get whole record
vault kv get -mount=terra-kv-zorg terra-vsphere-main-api

# update custom value in secret
vault kv patch -mount=terra-kv-zorg terra-vsphere-main-api password="bugaga"

# get custom value in secret
vault kv get -mount=terra-kv-zorg -field=password terra-vsphere-main-api

# remove secret
vault kv metadata delete -mount=terra-kv-zorg terra-vsphere-main-api

# disable our instance of kv engine
vault secrets disable terra-kv-zorg

---------------------------------------------------------------------------------------------------------------------------
# DEBUG
vault audit enable file file_path=/var/log/vault_audit.log
vault audit list
vault audit disable file 

---------------------------------------------------------------------------------------------------------------------------
# GETTING SECRETS VIA JWT TOKENS IN GITLAB CICD

# VAULT STAGE
#STEP 1 create kv-v2 variables

#STEP 2 create policy
vault policy list
cat << EOF > vault-policy-terra-ci-terraform-essentials.hcl
path "terra-kv-main/data/bind-dns-api" {
    capabilities = ["read"]
}
path "terra-kv-main/data/nexus-repo-tfstates" {
    capabilities = ["read"]
}
path "terra-kv-main/data/vsphere-api" {
    capabilities = ["read"]
}
EOF
vault policy write terra-ci-terraform-essentials vault-policy-terra-ci-terraform-essentials.hcl && vault policy list
vault policy read terra-ci-terraform-essentials

#STEP 3 enable jwt se instance
# FYI https://archives.docs.gitlab.com/15.11/ee/ci/examples/authenticating-with-hashicorp-vault/
vault auth list
vault auth enable -path="jwt" -description="jwt auth from gitlab.example.com" jwt && vault auth list
vault write auth/jwt/config jwks_url="https://gitlab.example.com/-/jwks" bound_issuer="gitlab.example.com" && vault read /auth/jwt/config

#STEP 4 create role
vault list auth/jwt/role/
cat << EOF > vault-role-k8s-dynamic.json
{
  "role_type": "jwt",
  "policies": [
    "terra-ci-terraform-essentials"
  ],
  "token_explicit_max_ttl": 60,
  "user_claim": "user_email",
  "bound_claims": {
    "project_id": "2941"
  }
}
EOF
vault write auth/jwt/role/k8s-dynamic @vault-role-k8s-dynamic.json && vault list auth/jwt/role/
vault read -format=json auth/jwt/role/k8s-dynamic | less

# GITLAB STAGE
.gitlab-ci.yml
...
.get-essential-terraform-variables:
  id_tokens:
    VAULT_ID_TOKEN:
      aud: https://dev-vault.example.com
  secrets:
    VSPHERE_SERVER:
      vault: vsphere-api/domain@terra-kv-main
      file: false
  variables:
    VAULT_SERVER_URL: "https://dev-vault.example.com"
    VAULT_AUTH_ROLE:  "k8s-dynamic"
...   
a:debug:
  stage: adhoc
  extends: .get-essential-terraform-variables
  needs: []
  script:
    - echo "${VSPHERE_SERVER^^}"
