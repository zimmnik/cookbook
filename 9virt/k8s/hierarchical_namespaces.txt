curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm
sudo rpm -Uvh minikube-latest.x86_64.rpm
minikube start --kubernetes-version='v1.20.7'

k get nodes

https://github.com/kubernetes-sigs/multi-tenancy/releases

# Select the latest version of HNC
HNC_VERSION=v0.8.0

# Forbid HNC from modifying system namespaces
kubectl label ns kube-system hnc.x-k8s.io/excluded-namespace=true --overwrite
kubectl label ns kube-public hnc.x-k8s.io/excluded-namespace=true --overwrite
kubectl label ns kube-node-lease hnc.x-k8s.io/excluded-namespace=true --overwrite

# Install HNC. Afterwards, wait up to 30s for HNC to refresh the certificates on its webhooks.
kubectl apply -f https://github.com/kubernetes-sigs/multi-tenancy/releases/download/hnc-${HNC_VERSION}/hnc-manager.yaml && sleep 30

#--------------------------------------------------------------------------------------------------------------------------
https://krew.sigs.k8s.io/docs/user-guide/setup/install/#bash
sudo yum -y install git
(
  set -x; cd "$(mktemp -d)" &&
  OS="$(uname | tr '[:upper:]' '[:lower:]')" &&
  ARCH="$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')" &&
  curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/krew.tar.gz" &&
  tar zxvf krew.tar.gz &&
  KREW=./krew-"${OS}_${ARCH}" &&
  "$KREW" install krew
)
echo 'export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"' >> ~/.bashrc && bash
k krew install hns

#-----------------------------------------------------------------------------------------------------------
# create a namespace for 1) acme-org organisation 2) a team within that org 3) a service owned by that team
k create namespace acme-org && k create namespace team-a && k create namespace service-1
# by default, there's no relationship between these namespaces.

# create Site Reliability Engineer (SRE) for team-a
k -n team-a create role team-a-sre --verb=update --resource=deployments
k -n team-a create rolebinding team-a-sres --role team-a-sre --serviceaccount=team-a:default

# create super-SRE group across the whole acme org
kubectl -n acme-org create role org-sre --verb=update --resource=deployments
kubectl -n acme-org create rolebinding org-sres --role org-sre --serviceaccount=acme-org:default

# none of this affects service-1, since that's a completely independent namespace,
kubectl -n service-1 get rolebindings

# make acme-org the parent of team-a
kubectl hns set team-a --parent acme-org

# this won't work, will be rejected since it would cause a cycle
kubectl hns set acme-org --parent team-a

# make team-a the parent of service-1
kubectl hns set service-1 --parent team-a

# display the hierarchy
kubectl hns tree acme-org

# check service-1 again, we'll see that the rolebindings from the ancestor namespaces have been propagated to the child namespace
kubectl -n service-1 describe roles && kubectl -n service-1 get rolebindings
# by default, HNC propagates RBAC Role and RoleBinding objects only.

# create ns without cluster-wide permission
k hns create team-b -n acme-org
# show hierarchy
k hns tree acme-org
# subnamespaces are created as a child of another namespace, and this parent can never be changed
# if the parent is deleted, so is the subnamespace too.

# create Site Reliability Engineer (SRE) for team-b
kubectl -n team-b create role team-b-wizard --verb=update --resource=deployments
kubectl -n team-b create rolebinding team-b-wizards --role team-b-wizard --serviceaccount=team-b:default

# assign the service to the new team
k hns set service-1 --parent team-b
# show hierarchy
k hns tree acme-org

# verify that the roles and rolebindings have been updated as well.
kubectl -n service-1 get roles && kubectl -n service-1 get rolebindings
